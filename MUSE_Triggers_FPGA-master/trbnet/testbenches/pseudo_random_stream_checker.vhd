--checks the data stream generated by pseudo_random_stream_generator
--width of compared bits is configurable via generics


LIBRARY ieee;
use ieee.std_logic_1164.all;
USE IEEE.numeric_std.ALL;

library work;
use work.trb_net_std.all;


entity pseudo_random_stream_checker is
  generic(
    WIDTH  : integer := 16
    );
  port(
    CLK    : in  std_logic;
    RESET  : in  std_logic;
    CLK_EN : in  std_logic;
    D_IN   : in  std_logic_vector(15 downto 0);
    D_EN   : in  std_logic;
    D_RST  : in  std_logic;
    FAIL   : out std_logic;
    MY_CRC_OUT: out std_logic_vector(15 downto 0)
    );
end entity;



architecture arch of pseudo_random_stream_checker is

  component trb_net_CRC is
    port(
      CLK       : in  std_logic;
      RESET     : in std_logic;
      CLK_EN    : in std_logic;
      DATA_IN   : in  std_logic_vector(15 downto 0);
      CRC_OUT   : out std_logic_vector(15 downto 0);
      CRC_match : out std_logic
      );
  end component;

  signal test_counter : unsigned(15 downto 0) := x"0000";
  signal CRC_reset    : std_logic;
  signal last_D_EN    : std_logic;
  signal last_D_RST   : std_logic;
  signal last_D_IN    : std_logic_vector(15 downto 0);
  signal CRC_out      : std_logic_vector(15 downto 0);
  signal detected_RST : std_logic := '1';
  signal rst_counter  : unsigned(3 downto 0) := x"0";
  signal tmp_DATA_IN  : std_logic_vector(15 downto 0);
begin

  THE_CRC : trb_net_CRC
    port map(
      CLK => CLK,
      RESET => CRC_reset,
      CLK_EN => D_EN,
      DATA_IN => tmp_DATA_IN(15 downto 0),
      CRC_OUT => CRC_out,
      CRC_match => open
      );
  tmp_DATA_IN <= std_logic_vector(test_counter);
  CRC_reset <= RESET or D_RST or detected_RST;
  MY_CRC_OUT <= CRC_out;

  process(CLK)
    begin
      if rising_edge(CLK) then
        last_D_RST <= D_RST;
        last_D_EN  <= D_EN;
        last_D_IN  <= D_IN;

        if  last_D_EN = '1' and last_D_RST = '0' then
          if CRC_out(WIDTH-1 downto 0) = std_logic_vector(last_D_IN(WIDTH-1 downto 0)) then
            FAIL <= '0';
          else
            FAIL <= '1';
          end if;
        end if;

        if last_D_RST = '1' or detected_RST = '1' then
          test_counter <= (others => '0');
        else
          test_counter <= test_counter + 1;
        end if;
      end if;
    end process;

  PROC_detect_reset : process(CLK)
    begin
      if rising_edge(CLK) then
        if RESET = '1' then
          detected_RST <= '1';
        else
          if rst_counter = x"8" then
            detected_RST <= '1';
          end if;
          if D_IN = x"0000" and D_EN = '1' and rst_counter < x"8" then
            rst_counter <= rst_counter + to_unsigned(1,1);
          elsif  D_IN /= x"0000" and D_EN = '1' then
            rst_counter <= (others => '0');
            detected_RST <= '0';
          end if;
        end if;
      end if;
    end process;


end architecture;